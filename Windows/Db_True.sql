/*
Deployment script for True-Manager-c2be6f64-4a58-4696-9a8b-740b0fcfd71a

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "True-Manager-Nov-2025"
:setvar DefaultFilePrefix "True-Manager-Nov-2025"
:setvar DefaultDataPath "C:\Program Files\Microsoft SQL Server\MSSQL16.SQLEXPRESS\MSSQL\DATA\"
:setvar DefaultLogPath "C:\Program Files\Microsoft SQL Server\MSSQL16.SQLEXPRESS\MSSQL\DATA\"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [master];


GO

IF (DB_ID(N'$(DatabaseName)') IS NOT NULL) 
BEGIN
    ALTER DATABASE [$(DatabaseName)]
    SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
    DROP DATABASE [$(DatabaseName)];
END

GO
PRINT N'Creating database $(DatabaseName)...'
GO
CREATE DATABASE [$(DatabaseName)]
GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_CLOSE OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
USE [$(DatabaseName)];


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ANSI_NULLS ON,
                ANSI_PADDING ON,
                ANSI_WARNINGS ON,
                ARITHABORT ON,
                CONCAT_NULL_YIELDS_NULL ON,
                NUMERIC_ROUNDABORT OFF,
                QUOTED_IDENTIFIER ON,
                ANSI_NULL_DEFAULT ON,
                CURSOR_DEFAULT LOCAL,
                RECOVERY FULL,
                CURSOR_CLOSE_ON_COMMIT OFF,
                AUTO_CREATE_STATISTICS ON,
                AUTO_SHRINK OFF,
                AUTO_UPDATE_STATISTICS ON,
                RECURSIVE_TRIGGERS OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ALLOW_SNAPSHOT_ISOLATION OFF;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET READ_COMMITTED_SNAPSHOT OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_UPDATE_STATISTICS_ASYNC OFF,
                PAGE_VERIFY NONE,
                DATE_CORRELATION_OPTIMIZATION OFF,
                DISABLE_BROKER,
                PARAMETERIZATION SIMPLE,
                SUPPLEMENTAL_LOGGING OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF IS_SRVROLEMEMBER(N'sysadmin') = 1
    BEGIN
        IF EXISTS (SELECT 1
                   FROM   [master].[dbo].[sysdatabases]
                   WHERE  [name] = N'$(DatabaseName)')
            BEGIN
                EXECUTE sp_executesql N'ALTER DATABASE [$(DatabaseName)]
    SET TRUSTWORTHY OFF,
        DB_CHAINING OFF 
    WITH ROLLBACK IMMEDIATE';
            END
    END
ELSE
    BEGIN
        PRINT N'The database settings cannot be modified. You must be a SysAdmin to apply these settings.';
    END


GO
IF IS_SRVROLEMEMBER(N'sysadmin') = 1
    BEGIN
        IF EXISTS (SELECT 1
                   FROM   [master].[dbo].[sysdatabases]
                   WHERE  [name] = N'$(DatabaseName)')
            BEGIN
                EXECUTE sp_executesql N'ALTER DATABASE [$(DatabaseName)]
    SET HONOR_BROKER_PRIORITY OFF 
    WITH ROLLBACK IMMEDIATE';
            END
    END
ELSE
    BEGIN
        PRINT N'The database settings cannot be modified. You must be a SysAdmin to apply these settings.';
    END


GO
ALTER DATABASE [$(DatabaseName)]
    SET TARGET_RECOVERY_TIME = 0 SECONDS 
    WITH ROLLBACK IMMEDIATE;


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET FILESTREAM(NON_TRANSACTED_ACCESS = OFF),
                CONTAINMENT = NONE 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_CREATE_STATISTICS ON(INCREMENTAL = OFF),
                MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT = OFF,
                DELAYED_DURABILITY = DISABLED 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET QUERY_STORE (QUERY_CAPTURE_MODE = ALL, DATA_FLUSH_INTERVAL_SECONDS = 900, INTERVAL_LENGTH_MINUTES = 60, MAX_PLANS_PER_QUERY = 200, CLEANUP_POLICY = (STALE_QUERY_THRESHOLD_DAYS = 367), MAX_STORAGE_SIZE_MB = 100) 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET QUERY_STORE = OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE SCOPED CONFIGURATION SET MAXDOP = 0;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET MAXDOP = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET LEGACY_CARDINALITY_ESTIMATION = OFF;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET LEGACY_CARDINALITY_ESTIMATION = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET PARAMETER_SNIFFING = ON;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET PARAMETER_SNIFFING = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET QUERY_OPTIMIZER_HOTFIXES = OFF;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET QUERY_OPTIMIZER_HOTFIXES = PRIMARY;
    END



GO
IF fulltextserviceproperty(N'IsFulltextInstalled') = 1
    EXECUTE sp_fulltext_database 'enable';


GO
PRINT N'Creating User-Defined Table Type [dbo].[DocMapping]...';


GO
CREATE TYPE [dbo].[DocMapping] AS TABLE (
    [MasterDocID] INT NULL,
    [ServerDocID] INT NULL);


GO
PRINT N'Creating Table [dbo].[Batch]...';


GO
CREATE TABLE [dbo].[Batch] (
    [BatchID]         INT           IDENTITY (1, 1) NOT NULL,
    [BatchName]       VARCHAR (256) NOT NULL,
    [ServerID]        INT           NULL,
    [IsBatchFinished] BIT           NULL,
    CONSTRAINT [PK_Batch_BatchID] PRIMARY KEY CLUSTERED ([BatchID] ASC),
    CONSTRAINT [UQ_Batch_BatchName] UNIQUE NONCLUSTERED ([BatchName] ASC)
);


GO
PRINT N'Creating Table [dbo].[BatchFileMapping]...';


GO
CREATE TABLE [dbo].[BatchFileMapping] (
    [BatchFileMappingID] INT IDENTITY (1, 1) NOT NULL,
    [BatchID]            INT NULL,
    [MasterDocID]        INT NULL,
    [ServerDocID]        INT NULL,
    CONSTRAINT [PK_BatchFileMapping_BatchFileMappingID] PRIMARY KEY CLUSTERED ([BatchFileMappingID] ASC)
);


GO
PRINT N'Creating Table [dbo].[Server]...';


GO
CREATE TABLE [dbo].[Server] (
    [ServerID]       INT           IDENTITY (1, 1) NOT NULL,
    [ServerName]     VARCHAR (256) NULL,
    [ServerURL]      VARCHAR (256) NULL,
    [ServerTypeID]   INT           NULL,
    [IsServerLocked] BIT           NULL,
    CONSTRAINT [PK_Server_ServerID] PRIMARY KEY CLUSTERED ([ServerID] ASC),
    CONSTRAINT [UQ_Server_ServerName] UNIQUE NONCLUSTERED ([ServerName] ASC)
);


GO
PRINT N'Creating Table [dbo].[ServerType]...';


GO
CREATE TABLE [dbo].[ServerType] (
    [ServerTypeID] INT          IDENTITY (1, 1) NOT NULL,
    [ServerType]   VARCHAR (64) NULL,
    CONSTRAINT [PK_ServerType_ServerTypeID] PRIMARY KEY CLUSTERED ([ServerTypeID] ASC)
);


GO
PRINT N'Creating Table [dbo].[UploadBatchQueue]...';


GO
CREATE TABLE [dbo].[UploadBatchQueue] (
    [Id]           INT           IDENTITY (1, 1) NOT NULL,
    [BatchName]    VARCHAR (255) NULL,
    [PriorityID]   INT           NULL,
    [CreatedOn]    DATETIME      NULL,
    [WorkflowType] VARCHAR (50)  NULL
);


GO
PRINT N'Creating Foreign Key [dbo].[FK_Batch_BatchID_Server_BatchID]...';


GO
ALTER TABLE [dbo].[Batch]
    ADD CONSTRAINT [FK_Batch_BatchID_Server_BatchID] FOREIGN KEY ([ServerID]) REFERENCES [dbo].[Server] ([ServerID]);


GO
PRINT N'Creating Foreign Key [dbo].[FK_BatchFileMapping_BatchID_Batch_BatchID]...';


GO
ALTER TABLE [dbo].[BatchFileMapping]
    ADD CONSTRAINT [FK_BatchFileMapping_BatchID_Batch_BatchID] FOREIGN KEY ([BatchID]) REFERENCES [dbo].[Batch] ([BatchID]);


GO
PRINT N'Creating Foreign Key [dbo].[FK_Server_ServerTypeID_ServerType_ServerTypeID]...';


GO
ALTER TABLE [dbo].[Server]
    ADD CONSTRAINT [FK_Server_ServerTypeID_ServerType_ServerTypeID] FOREIGN KEY ([ServerTypeID]) REFERENCES [dbo].[ServerType] ([ServerTypeID]);


GO
PRINT N'Creating Procedure [dbo].[AccessDocMappingsByBatch]...';


GO
-- =============================================
-- Author:		Shmuel Halbfinger
-- Create date: 02/14/2022
-- Description:	Get all Doc Mappings for a specific batch
-- =============================================
CREATE PROCEDURE [dbo].[AccessDocMappingsByBatch]
	@BatchName VARCHAR(255)
AS
BEGIN
	SET NOCOUNT ON;

	BEGIN TRANSACTION

	DECLARE @Error INT, @RowCount INT
	DECLARE @ErrorText VARCHAR(max)

	DECLARE @BatchID INT = (SELECT TOP 1 BatchID FROM Batch WHERE BatchName = @BatchName)

	SELECT @Error = @@ERROR
	IF (@Error <> 0) 
		BEGIN
		ROLLBACK TRANSACTION
		SET @ErrorText = (SELECT text FROM sys.Messages WHERE message_id = @Error)
		PRINT @ErrorText
		RETURN 1
		END

	SELECT MasterDocID, ServerDocID FROM BatchFileMapping WHERE BatchID = @BatchID

	SELECT @Error = @@ERROR
	IF (@Error <> 0) 
		BEGIN
		ROLLBACK TRANSACTION
		SET @ErrorText = (SELECT text FROM sys.Messages WHERE message_id = @Error)
		PRINT @ErrorText
		RETURN 1
		END

	COMMIT TRANSACTION

	RETURN 0
END
GO
PRINT N'Creating Procedure [dbo].[AddDocMapping]...';


GO
-- =============================================
-- Author:		Shmuel Halbfinger
-- Create date: 02/14/2022
-- Description:	Add a Doc Mapping for a specific batch
-- =============================================
CREATE PROCEDURE [dbo].[AddDocMapping]
	@BatchName VARCHAR(255),
	@MasterDocID INT,
	@ServerDocID INT
AS
BEGIN
	SET NOCOUNT ON;

	BEGIN TRANSACTION

	-- Check if the batch exists
	IF NOT EXISTS (SELECT 1 FROM Batch WHERE BatchName = @BatchName)
		BEGIN
		ROLLBACK TRANSACTION
		RAISERROR('The given batch does not exist', 16, 1)
		RETURN 1
		END

	DECLARE @BatchID INT = (SELECT TOP 1 BatchID FROM Batch WHERE BatchName = @BatchName)

	-- Insert Mapping
	INSERT INTO BatchFileMapping (BatchID, MasterDocID, ServerDocID)
	VALUES (@BatchID, @MasterDocID, @ServerDocID)
	
	IF (@@ERROR <> 0)
		BEGIN
		ROLLBACK TRANSACTION
		RAISERROR('There was an error uploading the batch', 16, 1)
		RETURN 1
		END

	COMMIT TRANSACTION
	RETURN 0
END
GO
PRINT N'Creating Procedure [dbo].[AddDocMappings]...';


GO
-- =============================================
-- Author:		Shmuel Halbfinger
-- Create date: 02/14/2022
-- Description:	Add a Doc Mapping for a specific batch
-- =============================================
CREATE PROCEDURE [dbo].[AddDocMappings]
	@BatchName VARCHAR(255),
	@DocMappings DocMapping READONLY
AS
BEGIN
	SET NOCOUNT ON;

	BEGIN TRANSACTION

	-- Check if the batch exists
	IF NOT EXISTS (SELECT 1 FROM Batch WHERE BatchName = @BatchName)
		BEGIN
		ROLLBACK TRANSACTION
		RAISERROR('The given batch does not exist', 16, 1)
		RETURN 1
		END

	DECLARE @BatchID INT = (SELECT TOP 1 BatchID FROM Batch WHERE BatchName = @BatchName)

	-- Insert Mapping
	INSERT INTO BatchFileMapping (BatchID, MasterDocID, ServerDocID)
	SELECT @BatchID, MasterDocID, ServerDocID FROM @DocMappings
	
	DECLARE @Error INT = @@ERROR
	IF (@Error <> 0)
		BEGIN
		ROLLBACK TRANSACTION
		DECLARE @ErrorText VARCHAR(max) = (SELECT text FROM sys.Messages WHERE message_id = @Error)
		PRINT @ErrorText
		RETURN 1
		END

	COMMIT TRANSACTION
	RETURN 0
END
GO
PRINT N'Creating Procedure [dbo].[AddServer]...';


GO
-- =============================================
-- Author:		Shmuel Halbfinger
-- Create date: 02/14/2022
-- Description:	Inserts a batch into the Batch table
-- =============================================
CREATE PROCEDURE [dbo].[AddServer]
	@ServerName VARCHAR(256),
	@ServerURL VARCHAR(256),
	@ServerType VARCHAR(64)
AS
BEGIN
	SET NOCOUNT ON;

	BEGIN TRANSACTION

	DECLARE @ServerTypeID INT = (SELECT ServerTypeID FROM ServerType WHERE ServerType = @ServerType)

	-- Check if the server already exists
	DECLARE @ExistingServerID INT
	SELECT @ExistingServerID = ServerID FROM Server WHERE ServerName = @ServerName

	IF @ExistingServerID IS NULL
		BEGIN
		-- Server doesn't exist, insert a new one
		INSERT INTO Server (ServerName, ServerURL, ServerTypeID, IsServerLocked)
		VALUES (@ServerName, @ServerURL, @ServerTypeID, 0)
		END
	ELSE
		BEGIN
		-- Server already exists, update its values
		UPDATE Server
		SET ServerURL = @ServerURL, ServerTypeID = @ServerTypeID
		WHERE ServerID = @ExistingServerID
		END

	DECLARE @Error INT = @@ERROR
	IF (@Error <> 0)
		BEGIN
		ROLLBACK TRANSACTION
		DECLARE @ErrorText VARCHAR(max) = (SELECT text FROM sys.Messages WHERE message_id = @Error)
		PRINT @ErrorText
		RETURN 1
		END

	COMMIT TRANSACTION
	RETURN 0
END
GO
PRINT N'Creating Procedure [dbo].[AssignBatchToServer]...';


GO
-- =============================================
-- Author:		Shmuel Halbfinger
-- Create date: 02/14/2022
-- Description:	Assign a batch to a specific server
-- =============================================
CREATE PROCEDURE [dbo].[AssignBatchToServer]
	@BatchID int,
	@ServerID int
AS
BEGIN
	SET NOCOUNT ON;

	BEGIN TRANSACTION

	-- Check if the batch exists
	IF NOT EXISTS (SELECT 1 FROM Batch WHERE BatchID = @BatchID)
		BEGIN
		ROLLBACK TRANSACTION
		RAISERROR('The given batch does not exist', 16, 1)
		RETURN 1
		END

	-- Check if server exists
	IF NOT EXISTS (SELECT 1 FROM Server WHERE ServerID = @ServerID)
		BEGIN
		ROLLBACK TRANSACTION
		RAISERROR('The given server does not exist', 16, 1)
		RETURN 1
		END

	-- Insert Batch
	Update Batch
	SET ServerID = @ServerID
	WHERE BatchID = @BatchID
	
	DECLARE @Error INT = @@ERROR
	IF (@Error <> 0)
		BEGIN
		ROLLBACK TRANSACTION
		DECLARE @ErrorText VARCHAR(max) = (SELECT text FROM sys.Messages WHERE message_id = @Error)
		PRINT @ErrorText
		RETURN 1
		END

	COMMIT TRANSACTION

	SELECT BatchID, BatchName, ServerID
	FROM Batch
	WHERE BatchID = @BatchID

	RETURN 0
END
GO
PRINT N'Creating Procedure [dbo].[ClearManagerDatabase]...';


GO
-- =============================================
-- Author:		Shmuel Halbfinger
-- Create date: 02/14/2022
-- Description:	Clear entire manager database
-- =============================================
CREATE PROCEDURE [dbo].[ClearManagerDatabase]
AS
BEGIN
	SET NOCOUNT ON;

	BEGIN TRANSACTION

	DECLARE @Error INT, @ErrorText VARCHAR(max)

	DELETE FROM UploadBatchQueue

	SELECT @Error = @@ERROR
	IF (@Error <> 0) 
		BEGIN
		ROLLBACK TRANSACTION
		SET @ErrorText = (SELECT text FROM sys.Messages WHERE message_id = @Error)
		PRINT @ErrorText
		RETURN 1
		END

	DELETE FROM BatchFileMapping

	SELECT @Error = @@ERROR
	IF (@Error <> 0) 
		BEGIN
		ROLLBACK TRANSACTION
		SET @ErrorText = (SELECT text FROM sys.Messages WHERE message_id = @Error)
		PRINT @ErrorText
		RETURN 1
		END

	DELETE FROM Batch

	SELECT @Error = @@ERROR
	IF (@Error <> 0) 
		BEGIN
		ROLLBACK TRANSACTION
		SET @ErrorText = (SELECT text FROM sys.Messages WHERE message_id = @Error)
		PRINT @ErrorText
		RETURN 1
		END

	DELETE FROM Server

	SELECT @Error = @@ERROR
	IF (@Error <> 0) 
		BEGIN
		ROLLBACK TRANSACTION
		SET @ErrorText = (SELECT text FROM sys.Messages WHERE message_id = @Error)
		PRINT @ErrorText
		RETURN 1
		END

	COMMIT TRANSACTION

	RETURN 0
END
GO
PRINT N'Creating Procedure [dbo].[DeleteBatch]...';


GO
-- =============================================
-- Author:		Shmuel Halbfinger
-- Create date: 02/14/2022
-- Description:	Clear entire manager database
-- =============================================
CREATE PROCEDURE [dbo].[DeleteBatch]
	@BatchName VARCHAR(255)
AS
BEGIN
	SET NOCOUNT ON;

	BEGIN TRANSACTION

	DECLARE @Error INT, @ErrorText VARCHAR(max), @Count INT

	DELETE FROM BatchFileMapping
	WHERE BatchID = (SELECT TOP 1 BatchID FROM Batch WHERE BatchName = @BatchName)

	SELECT @Error = @@ERROR, @Count = @@ROWCOUNT
	IF (@Error <> 0) 
		BEGIN
		ROLLBACK TRANSACTION
		SET @ErrorText = (SELECT text FROM sys.Messages WHERE message_id = @Error)
		PRINT @ErrorText
		RETURN 1
		END
	ELSE IF (@Count = 0)
		BEGIN
		ROLLBACK TRANSACTION
		RAISERROR('The given batch does not exist', 16, 1)
		RETURN 1
		END

	DELETE FROM Batch WHERE BatchName = @BatchName

	SELECT @Error = @@ERROR, @Count = @@ROWCOUNT
	IF (@Error <> 0) 
		BEGIN
		ROLLBACK TRANSACTION
		SET @ErrorText = (SELECT text FROM sys.Messages WHERE message_id = @Error)
		PRINT @ErrorText
		RETURN 1
		END
	ELSE IF (@Count = 0)
		BEGIN
		ROLLBACK TRANSACTION
		RAISERROR('The given batch does not exist', 16, 1)
		RETURN 1
		END

	COMMIT TRANSACTION

	RETURN 0
END
GO
PRINT N'Creating Procedure [dbo].[DeleteDocMappingsForBatch]...';


GO
-- =============================================
-- Author:		Shmuel Halbfinger
-- Create date: 01/19/2023
-- Description:	Dekete Doc Mappings for a Given Batch
-- =============================================
CREATE PROCEDURE [dbo].[DeleteDocMappingsForBatch]
	@BatchName VARCHAR(255)
AS
BEGIN
	SET NOCOUNT ON;

	BEGIN TRANSACTION

	DECLARE @Error INT
	DECLARE @ErrorText VARCHAR(max)

	DECLARE @BatchID INT = (SELECT TOP 1 BatchID FROM Batch WHERE BatchName = @BatchName)

	SELECT @Error = @@ERROR
	IF (@Error <> 0) 
		BEGIN
		ROLLBACK TRANSACTION
		SET @ErrorText = (SELECT text FROM sys.Messages WHERE message_id = @Error)
		PRINT @ErrorText
		RETURN 1
		END

	DELETE FROM BatchFileMapping WHERE BatchID = @BatchID

	SELECT @Error = @@ERROR
	IF (@Error <> 0) 
		BEGIN
		ROLLBACK TRANSACTION
		SET @ErrorText = (SELECT text FROM sys.Messages WHERE message_id = @Error)
		PRINT @ErrorText
		RETURN 1
		END

	COMMIT TRANSACTION

	RETURN 0
END
GO
PRINT N'Creating Procedure [dbo].[DequeueUploadBatch]...';


GO
-- =============================================
-- Author:		Shmuel Halbfinger
-- Create date: 02/14/2022
-- Description:	Inserts a batch into the Batch table
-- =============================================
CREATE PROCEDURE [dbo].[DequeueUploadBatch]

AS
BEGIN
	SET NOCOUNT ON;

	BEGIN TRANSACTION
	DECLARE @DequeuedBatch TABLE (BatchName VARCHAR(255) NULL, WorkflowType VARCHAR(50) NULL)
	DECLARE @Error INT, @RowCount INT

	-- Insert Batch. There is a unique constraint on the batchname, so no need to check
	DELETE FROM UploadBatchQueue OUTPUT deleted.BatchName, deleted.WorkflowType INTO @DequeuedBatch
	WHERE BatchName =
		(SELECT TOP 1 BatchName FROM UploadBatchQueue WITH (ROWLOCK XLOCK)
		ORDER BY
		PriorityID DESC,
		(CASE WorkflowType
		 WHEN 'finalvalidation' THEN 1
		 WHEN 'incomplete' THEN 2
		 WHEN 'extraction' THEN 3
		 WHEN 'classification' THEN 4 END) ASC,
		CreatedOn ASC)

	SELECT @Error = @@ERROR, @RowCount = @@ROWCOUNT
	IF (@Error <> 0)
		BEGIN
		ROLLBACK TRANSACTION
		DECLARE @ErrorText VARCHAR(max) = (SELECT text FROM sys.Messages WHERE message_id = @Error)
		PRINT @ErrorText
		RETURN 1
		END
	ELSE IF @RowCount = 0
		BEGIN
		ROLLBACK TRANSACTION
		PRINT 'There are no queued batches'
		RETURN 1
		END

	SELECT TOP 1 BatchName, WorkflowType FROM @DequeuedBatch

	COMMIT TRANSACTION

	RETURN 0
END
GO
PRINT N'Creating Procedure [dbo].[GetAllQueuedBatches]...';


GO
-- =============================================
-- Author:		Shmuel Halbfinger
-- Create date: 02/14/2022
-- Description:	Get all batches in the queue
-- =============================================
CREATE PROCEDURE [dbo].[GetAllQueuedBatches]
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @Error INT, @RowCount INT

	-- Insert Batch. There is a unique constraint on the batchname, so no need to check
	SELECT ID, BatchName FROM UploadBatchQueue

	IF (@@ROWCOUNT = 0) BEGIN
	PRINT 'No batches in Upload Queue'
	END

	RETURN 0
END
GO
PRINT N'Creating Procedure [dbo].[GetManagerServers]...';


GO
-- =============================================
-- Author:		Jason Chou
-- Create date: 02/14/2024
-- Description:	Get all servers in the server list
-- =============================================
CREATE PROCEDURE GetManagerServers
AS
BEGIN
    SET NOCOUNT ON;

    SELECT s.ServerID, s.ServerName, s.ServerURL, st.ServerTypeID, s.IsServerLocked
    FROM [dbo].[Server] AS s
    INNER JOIN [dbo].[ServerType] AS st ON s.ServerTypeID = st.ServerTypeID
    WHERE st.ServerType = 'Manager';
END;
GO
PRINT N'Creating Procedure [dbo].[GetServerByName]...';


GO
-- =============================================
-- Author:		Jason Chou
-- Create date: 02/14/2024
-- Description:	Get server from server list by name
-- =============================================
CREATE PROCEDURE GetServerByName
    @ServerName VARCHAR(256)
AS
BEGIN
    SET NOCOUNT ON;

    SELECT ServerID, ServerName, ServerURL, ServerTypeID, IsServerLocked
    FROM [dbo].[Server]
    WHERE ServerName = @ServerName;
END;
GO
PRINT N'Creating Procedure [dbo].[InsertBatch]...';


GO
-- =============================================
-- Author:		Shmuel Halbfinger
-- Create date: 02/14/2022
-- Description:	Inserts a batch into the Batch table
-- =============================================
CREATE PROCEDURE [dbo].[InsertBatch]
	@BatchName VARCHAR(255)
AS
BEGIN
	SET NOCOUNT ON;

	BEGIN TRANSACTION

	-- Insert Batch. There is a unique constraint on the batchname, so no need to check
	INSERT INTO Batch (BatchName, IsBatchFinished) VALUES (@BatchName, 0)
	
	DECLARE @Error INT = @@ERROR
	IF (@Error <> 0)
		BEGIN
		ROLLBACK TRANSACTION
		DECLARE @ErrorText VARCHAR(max) = (SELECT text FROM sys.Messages WHERE message_id = @Error)
		PRINT @ErrorText
		RETURN 1
		END

	COMMIT TRANSACTION

	SELECT BatchID, BatchName FROM Batch
	WHERE BatchName = @BatchName

	RETURN 0
END
GO
PRINT N'Creating Procedure [dbo].[LockAllServers]...';


GO
-- =============================================
-- Author:		Shmuel Halbfinger
-- Create date: 02/14/2022
-- Description:	Locks all servers
-- =============================================
CREATE PROCEDURE [dbo].[LockAllServers]

AS
BEGIN
	SET NOCOUNT ON;

	BEGIN TRANSACTION

	DECLARE @Error INT, @RowCount INT, @return_value INT = 0

	DECLARE @ServerLockedCount INT = (SELECT COUNT(*) FROM Server WITH (TABLOCKX) WHERE IsServerLocked = 1)

	IF @ServerLockedCount > 0 BEGIN
		ROLLBACK TRANSACTION
		RAISERROR('One or more servers are already locked', 16, 1)
		SET @return_value = 1
		RETURN @return_value
		END

	-- Insert Server. There is a unique constraint on the ServerName, so no need to check
	UPDATE Server
	SET IsServerLocked = 1
	
	SELECT @Error = @@ERROR, @RowCount = @@ROWCOUNT

	IF (@Error <> 0) 
		BEGIN
		ROLLBACK TRANSACTION
		DECLARE @ErrorText VARCHAR(max) = (SELECT text FROM sys.Messages WHERE message_id = @Error)
		PRINT @ErrorText
		SET @return_value = 1
		RETURN @return_value
		END
	ELSE IF (@RowCount = 0)
		BEGIN
		ROLLBACK TRANSACTION
		RAISERROR('There are no servers', 16, 1)
		SET @return_value = 1
		RETURN @return_value
		END

	COMMIT TRANSACTION
	RETURN @return_value
END
GO
PRINT N'Creating Procedure [dbo].[LockServer]...';


GO
-- =============================================
-- Author:		Shmuel Halbfinger
-- Create date: 02/14/2022
-- Description:	Inserts a batch into the Batch table
-- =============================================
CREATE PROCEDURE [dbo].[LockServer]
	@ServerName VARCHAR(256)
AS
BEGIN
	SET NOCOUNT ON;

	BEGIN TRANSACTION

	DECLARE @Error INT, @RowCount INT, @return_value INT = 0

	-- Insert Server. There is a unique constraint on the ServerName, so no need to check
	UPDATE Server
	SET IsServerLocked = 1
	WHERE ServerName = @ServerName
	AND IsServerLocked = 0
	
	SELECT @Error = @@ERROR, @RowCount = @@ROWCOUNT

	IF (@Error <> 0) 
		BEGIN
		ROLLBACK TRANSACTION
		DECLARE @ErrorText VARCHAR(max) = (SELECT text FROM sys.Messages WHERE message_id = @Error)
		PRINT @ErrorText
		SET @return_value = 1
		RETURN @return_value
		END
	ELSE IF (@RowCount = 0)
		BEGIN
		IF NOT EXISTS (SELECT 1 FROM Server WHERE ServerName = @ServerName)
			BEGIN
			ROLLBACK TRANSACTION
			RAISERROR('The given server does not exist', 16, 1)
			SET @return_value = 2
			RETURN @return_value
			END
		ELSE
			BEGIN
			ROLLBACK TRANSACTION
			PRINT 'The given server has already been locked'
			SET @return_value = 3
			RETURN @return_value
			END
		END

	COMMIT TRANSACTION
	RETURN @return_value
END
GO
PRINT N'Creating Procedure [dbo].[LockSpecificServer]...';


GO
-- =============================================
-- Author:		Shmuel Halbfinger
-- Create date: 02/14/2022
-- Description:	Locks specific server
-- =============================================
CREATE PROCEDURE [dbo].[LockSpecificServer]
	@ServerName VARCHAR(256),
	@ServerType VARCHAR(64)
AS
BEGIN
	SET NOCOUNT ON;

	BEGIN TRANSACTION

	DECLARE @ServerTypeID INT = (SELECT ServerTypeID FROM ServerType WHERE ServerType = @ServerType)

	IF @ServerTypeID IS NULL
		BEGIN
		ROLLBACK TRANSACTION
		RAISERROR('Invalid server type', 16, 1)
		RETURN 1
		END

	DECLARE @Error INT, @RowCount INT, @return_value INT = 0

	DECLARE @LockedServerCount INT = (
		SELECT COUNT(*)
		FROM Server WITH (TABLOCKX)
		WHERE ServerTypeID = @ServerTypeID AND IsServerLocked = 1
	)

	DECLARE @IsGivenServerLocked BIT = (
		SELECT 1
		FROM Server WITH (TABLOCKX)
		WHERE ServerTypeID = @ServerTypeID AND IsServerLocked = 1 AND ServerName = @ServerName
	)

	-- Grant access to the critical section if there is a lock held by the same servername OR
	-- there are no servers locked
	IF (@LockedServerCount = 1 AND @IsGivenServerLocked = 1) OR
	    @LockedServerCount = 0
		BEGIN

		UPDATE Server
		SET IsServerLocked = 1
		WHERE ServerTypeID = @ServerTypeID AND ServerName = @ServerName

		SELECT @Error = @@ERROR, @RowCount = @@ROWCOUNT

		IF (@Error <> 0)
			BEGIN
			ROLLBACK TRANSACTION
			DECLARE @ErrorText VARCHAR(max) = (SELECT text FROM sys.Messages WHERE message_id = @Error)
			PRINT @ErrorText
			SET @return_value = 1
			RETURN @return_value
			END
		END
	ELSE
		BEGIN

		ROLLBACK TRANSACTION

		IF (@LockedServerCount > 1)
			BEGIN
			RAISERROR('Multiple managers are currently locked', 16, 1)
			END

		RETURN 1
		END

	COMMIT TRANSACTION
	RETURN @return_value
END
GO
PRINT N'Creating Procedure [dbo].[QueueUploadBatch]...';


GO
-- =============================================
-- Author:		Shmuel Halbfinger
-- Create date: 02/14/2022
-- Description:	Inserts a batch into the Batch table
-- =============================================
CREATE PROCEDURE [dbo].[QueueUploadBatch]
	@BatchName VARCHAR(255),
	@PriorityID INT,
	@CreatedOn DATETIME,
	@WorkflowType VARCHAR(50)
AS
BEGIN
	SET NOCOUNT ON;

	BEGIN TRANSACTION
	DECLARE @Error INT, @RowCount INT

	-- Insert Batch. There is a unique constraint on the batchname, so no need to check
	INSERT INTO UploadBatchQueue (BatchName, PriorityID, CreatedOn, WorkflowType)
	VALUES (@BatchName, @PriorityID, @CreatedOn, @WorkflowType)
	
	SELECT @Error = @@ERROR, @RowCount = @@ROWCOUNT
	IF (@Error <> 0 OR @RowCount = 0)
		BEGIN
		ROLLBACK TRANSACTION
		PRINT 'An error occurred in QueueUploadBatch'
		RETURN 1
		END

	COMMIT TRANSACTION

	RETURN 0
END
GO
PRINT N'Creating Procedure [dbo].[UnlockAllBatches]...';


GO
-- =============================================
-- Author:		Shmuel Halbfinger
-- Create date: 02/14/2022
-- Description:	Unlock all batches
-- =============================================
CREATE PROCEDURE [dbo].[UnlockAllBatches]

AS
BEGIN
	SET NOCOUNT ON;

	BEGIN TRANSACTION

	DECLARE @Error INT, @RowCount INT, @return_value INT = 0

	-- Insert Server. There is a unique constraint on the ServerName, so no need to check
	UPDATE Batch
	SET IsBatchFinished = 0
	
	SELECT @Error = @@ERROR, @RowCount = @@ROWCOUNT

	IF (@Error <> 0) 
		BEGIN
		ROLLBACK TRANSACTION
		DECLARE @ErrorText VARCHAR(max) = (SELECT text FROM sys.Messages WHERE message_id = @Error)
		PRINT @ErrorText
		SET @return_value = 1
		RETURN @return_value
		END
	ELSE IF (@RowCount = 0)
		BEGIN
		ROLLBACK TRANSACTION
		RAISERROR('There are no batches', 16, 1)
		SET @return_value = 1
		RETURN @return_value
		END

	COMMIT TRANSACTION
	RETURN @return_value
END
GO
PRINT N'Creating Procedure [dbo].[UnlockAllBatchesAndServers]...';


GO
-- =============================================
-- Author:		Shmuel Halbfinger
-- Create date: 02/14/2022
-- Description:	Unlock all batches and servers
-- =============================================
CREATE PROCEDURE [dbo].[UnlockAllBatchesAndServers]

AS
BEGIN
	SET NOCOUNT ON;

	BEGIN TRANSACTION

	DECLARE @Error INT, @RowCount INT, @return_value INT = 0

	-- Insert Server. There is a unique constraint on the ServerName, so no need to check
	UPDATE Batch
	SET IsBatchFinished = 0
	
	SELECT @Error = @@ERROR, @RowCount = @@ROWCOUNT

	IF (@Error <> 0) 
		BEGIN
		ROLLBACK TRANSACTION
		DECLARE @ErrorText VARCHAR(max) = (SELECT text FROM sys.Messages WHERE message_id = @Error)
		PRINT @ErrorText
		SET @return_value = 1
		RETURN @return_value
		END
	ELSE IF (@RowCount = 0)
		BEGIN
		ROLLBACK TRANSACTION
		RAISERROR('There are no batches', 16, 1)
		SET @return_value = 1
		RETURN @return_value
		END

	UPDATE Server
	SET IsServerLocked = 0
	
	SELECT @Error = @@ERROR, @RowCount = @@ROWCOUNT

	IF (@Error <> 0) 
		BEGIN
		ROLLBACK TRANSACTION
		DECLARE @ErrorText1 VARCHAR(max) = (SELECT text FROM sys.Messages WHERE message_id = @Error)
		PRINT @ErrorText1
		SET @return_value = 1
		RETURN @return_value
		END
	ELSE IF (@RowCount = 0)
		BEGIN
		ROLLBACK TRANSACTION
		RAISERROR('There are no servers', 16, 1)
		SET @return_value = 1
		RETURN @return_value
		END

	COMMIT TRANSACTION
	RETURN @return_value
END
GO
PRINT N'Creating Procedure [dbo].[UnlockAllServers]...';


GO
-- =============================================
-- Author:		Shmuel Halbfinger
-- Create date: 02/14/2022
-- Description:	Locks all servers
-- =============================================
CREATE PROCEDURE [dbo].[UnlockAllServers]

AS
BEGIN
	SET NOCOUNT ON;

	BEGIN TRANSACTION

	DECLARE @Error INT, @RowCount INT, @return_value INT = 0

	-- Insert Server. There is a unique constraint on the ServerName, so no need to check
	UPDATE Server
	SET IsServerLocked = 0
	
	SELECT @Error = @@ERROR, @RowCount = @@ROWCOUNT

	IF (@Error <> 0) 
		BEGIN
		ROLLBACK TRANSACTION
		DECLARE @ErrorText VARCHAR(max) = (SELECT text FROM sys.Messages WHERE message_id = @Error)
		PRINT @ErrorText
		SET @return_value = 1
		RETURN @return_value
		END
	ELSE IF (@RowCount = 0)
		BEGIN
		ROLLBACK TRANSACTION
		RAISERROR('There are no servers', 16, 1)
		SET @return_value = 1
		RETURN @return_value
		END

	COMMIT TRANSACTION
	RETURN @return_value
END
GO
PRINT N'Creating Procedure [dbo].[UnlockBatch]...';


GO
-- =============================================
-- Author:		Shmuel Halbfinger
-- Create date: 02/14/2022
-- Description:	Get all Doc Mappings for a specific batch
-- =============================================
CREATE PROCEDURE [dbo].[UnlockBatch]
	@BatchName VARCHAR(255)
AS
BEGIN
	SET NOCOUNT ON;

	BEGIN TRANSACTION

	DECLARE @Error INT, @RowCount INT

	UPDATE Batch
	SET IsBatchFinished = 0
	WHERE BatchName = @BatchName
	AND IsBatchFinished = 1

	SELECT @Error = @@ERROR, @RowCount = @@ROWCOUNT

	IF (@Error <> 0) 
		BEGIN
		ROLLBACK TRANSACTION
		DECLARE @ErrorText VARCHAR(max) = (SELECT text FROM sys.Messages WHERE message_id = @Error)
		PRINT @ErrorText
		RETURN 1
		END
	ELSE IF (@RowCount = 0)
		BEGIN
		IF NOT EXISTS (SELECT 1 FROM Batch WHERE BatchName = @BatchName)
			BEGIN
			ROLLBACK TRANSACTION
			RAISERROR('The given batch does not exist', 16, 1)
			RETURN 1
			END
		ELSE
			BEGIN
			ROLLBACK TRANSACTION
			PRINT 'The given batch is already exist'
			RETURN 1
			END
		END

	COMMIT TRANSACTION

	RETURN 0
END
GO
PRINT N'Creating Procedure [dbo].[UnlockServer]...';


GO
-- =============================================
-- Author:		Shmuel Halbfinger
-- Create date: 02/14/2022
-- Description:	Get all Doc Mappings for a specific batch
-- =============================================
CREATE PROCEDURE [dbo].[UnlockServer]
	@ServerName VARCHAR(255)
AS
BEGIN
	SET NOCOUNT ON;

	BEGIN TRANSACTION

	DECLARE @Error INT, @RowCount INT

	UPDATE Server
	SET IsServerLocked = 0
	WHERE ServerName = @ServerName
	AND IsServerLocked = 1

	SELECT @Error = @@ERROR, @RowCount = @@ROWCOUNT

	IF (@Error <> 0) 
		BEGIN
		ROLLBACK TRANSACTION
		DECLARE @ErrorText VARCHAR(max) = (SELECT text FROM sys.Messages WHERE message_id = @Error)
		PRINT @ErrorText
		RETURN 1
		END
	ELSE IF (@RowCount = 0)
		BEGIN
		IF NOT EXISTS (SELECT 1 FROM Server WHERE ServerName = @ServerName)
			BEGIN
			ROLLBACK TRANSACTION
			RAISERROR('The given server does not exist', 16, 1)
			RETURN 1
			END
		ELSE
			BEGIN
			ROLLBACK TRANSACTION
			PRINT 'The given server is already unlocked'
			RETURN 1
			END
		END

	COMMIT TRANSACTION

	RETURN 0
END
GO
/*
Post-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be appended to the build script.		
 Use SQLCMD syntax to include a file in the post-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the post-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/

INSERT INTO [dbo].[ServerType] ([ServerType])
VALUES ('Worker'), ('Master'), ('Manager');

DECLARE		
	@cmd varchar(max),
	@UserName varchar(max)='cvisiondb', 
	@Passwd varchar(max)='cv88%connect'
IF NOT EXISTS (SELECT name FROM master.dbo.syslogins WHERE name = @UserName) BEGIN
	IF NOT EXISTS(SELECT loginname FROM master.sys.syslogins WHERE loginname=@UserName) BEGIN 
		SET @cmd = '' 
		SET @cmd = 'CREATE LOGIN ' + QUOTENAME(@UserName) + ' WITH PASSWORD =' + '''' + @Passwd + '''' + ', CHECK_POLICY=OFF'; 
		--print @cmd 
		EXEC (@cmd) 
		EXEC sp_addsrvrolemember @UserName, 'dbcreator'; 
	END
END

IF (IS_ROLEMEMBER ('db_owner',@UserName) = 1 )BEGIN
	PRINT 'User Already a Member'
END
ELSE IF (@UserName <> 'cvisiondb') BEGIN
	SET @cmd = 'CREATE USER ' + QUOTENAME(@UserName) + ' FOR LOGIN ' + QUOTENAME(@UserName) + ' WITH DEFAULT_SCHEMA = ' + '[' +DB_NAME() + ']'; 
	--PRINT @cmd 
	EXEC (@cmd) 
	EXEC sp_addrolemember 'db_accessadmin', @UserName; 
	EXEC sp_addrolemember 'db_datawriter', @UserName; 
	EXEC sp_addrolemember 'db_datareader', @UserName; 
	EXEC sp_addrolemember 'db_owner', @UserName;
END
GO

GO
DECLARE @VarDecimalSupported AS BIT;

SELECT @VarDecimalSupported = 0;

IF ((ServerProperty(N'EngineEdition') = 3)
    AND (((@@microsoftversion / power(2, 24) = 9)
          AND (@@microsoftversion & 0xffff >= 3024))
         OR ((@@microsoftversion / power(2, 24) = 10)
             AND (@@microsoftversion & 0xffff >= 1600))))
    SELECT @VarDecimalSupported = 1;

IF (@VarDecimalSupported > 0)
    BEGIN
        EXECUTE sp_db_vardecimal_storage_format N'$(DatabaseName)', 'ON';
    END


GO
PRINT N'Update complete.';


GO
